\section{Background}

Urd is the primary job dispatcher for the framework, and it is much
more than that.  Urd is a transaction-log-based service keeping track
of all jobs for all users of a framework setup.

The idea is that each user of the framework has one or more locations
in the database where information about executed jobs are stored.
These locations are called urd-lists.  The lists are readable to
anyone, but due to authorisation only writeable by the owning user.

With the exception of experimental work, all work initiated by urd is
run in closed sessons, with a well defined start and ending point.
The input dependencies to these sessions are recorded, together with
the resulting output.



\section{Urd sessions}

A minimal urd session looks like this

\begin{python}
def main(urd):
  urd.begin('test')
  ...
  urd.finish('test', '20161025')
\end{python}
This records any jobs carried out between the begin-finish lines into
the list test with a timestamp of '20161025'.

The session takes a number of options

\begin{python}
  urd.begin(path, timestamp=None, caption=None, update=False)
  urd.finish(path, timestamp=None, caption=None)
\end{python}
and these rules apply
\begin{itemize}
  \item the same path must be specified in both begin and finish.
  \item timestamp is mandatory, but could be set in either begin or
    finish.  Finish overrides begin.
  \item caption is mandatory, but could be set in either begin or
    finish.  Finish overrides begin.
  \item update ???
\end{itemize}

When a session is initiated, a new session cannot start until the
current has finished.  A session may be aborted, however

\begin{python}
  urd.begin('test')
  urd.abort()
\end{python}



\section{Building jobs}

Jobs may be dispatched in a running session.  The syntax is as follows

\begin{python}
  jobid = urd.build('method1', options={}, datasets={}, jobids={},)
\end{python}
where options, datasets, and jobids are optional, depending on the
method to be dispatched.  A jobid is returned upon successful
completion.

In addition, a name and a caption may optionally be specified

\begin{python}
  jobid = urd.build('method1', name='myjob', caption='looking for something')
\end{python}

The name will replace the method name in the joblist, in this case,
this job will now be referred to as myjob, and not method1.  




\subsection{Building chained jobs}
It is also possible to build chained jobs implicitly using

\begin{python}
  jobid = urd.build_chained('method1', name='myjob')
\end{python}
which takes exactly the same options as the standard build() method,
with the exception that name is mandatory, since it is used to find
the previous job of matching type.


\subsection{Debug:  Why build}

Bye speficying the flag why\_build to the automatarunner it is
possible to see the reasons for building a job.  For example

\begin{python}
  print urd.build('method3', jobids=dict(firstjob=jid2, secondjob=jid2), name='knut')
# Would have built from:
# ======================
# {
#     "caption": "fsm_method3", 
#     "method": "method3", 
#     "params": {
#         "method3": {
#             "datasets": {}, 
#             "jobids": {
#                 "firstjob": "test-59_0", 
#                 "secondjob": "test-59_0"
#             }, 
#             "options": {}
#         }
#     }, 
#     "why_build": "on_build"
# }
# Could have avoided build if:
# ============================
# {
#     "method3": {
#         "test-60_0": {
#             "jobids": {
#                 "firstjob": "test-56_0"
#             }
#         }
#     }
# }
\end{python}
A more machine-friendly output is possible by spefifying
why\_build=True in the build()-request (and not specifying it to the
automatarunner).



\section{Sessions with dependency}

Assume that a method, method1, uses some kind of imported transaction
logs, called tlog.  When dispatching method1, it should be using the
latest tlog.  This is achieved in the following example

\begin{python}
def main(urd):
  urd.begin('test')
  latest_tlog = urd.latest('tlog').joblist.jobid
  urd.build('method1', datasets=(tlog=latest_tlog))
  urd.finish('test', '20161025')
\end{python}
The latest()-function will record a dependency of tlog to method1.

\begin{python}
  urd.get('test', '20161001')
  urd.latest('test')
  urd.first('test')
\end{python}

Running on yesterday's tlog data

\begin{python}
def main(urd):
  urd.begin('test')
  tlog = urd.get('tlog', '20161024').joblist.jobid
  urd.build('method1', datasets=(tlog=tlog))
  urd.finish('test', '20161025')
\end{python}



\section{Avoiding recording dependency}
There are peek-variants available that do not record dependencies.

\begin{python}
  urd.peek('test', '20161025')
  urd.peek_latest('test')
  urd.peek_first('test')
\end{python}



\section{Truncating and Updating}

Urd will always keep a consistent history of all events taken place.
Sometimes, however, it makes sense to re-run events from the past.
There are two means to achieve this

\subsubsection{update}
The begin-function takes an optional argument update

\begin{python}
  urd.begin('test', '20161025', update=True)
\end{python}
If update is True, the entry in the test list at '20161025' will be
updated, unless there has been no change.

\subsubsection{Truncate}

The truncate() class member is used to rollback an arbitrary amount of
an urd list.

\begin{python}
  urd.truncate('test', '20160930')
\end{python}
This will rollback everything that has happened in the test list back
to '20160930'.  Internally, urd stores the complete history, however.



\section{Urd HTTP\_API}

In some situations it is convenient to make calls to urd directly
without using the framework.  Urd will react to HTTP requests.

\begin{shell}
% curl http://localhost:8833/list
["ab/test"]

% curl http://localhost:8833/ab/test/latest
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56_0"],
  ["method2", "test-59_0"], ["method3", "test-60_0"]]}

% curl http://localhost:8833/ab/test/first
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56_0"],
  ["method2", "test-59_0"], ["method3", "test-60_0"]]}

% curl http://localhost:8833/ab/test/20161025
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56_0"],
  ["method2", "test-59_0"], ["method3", "test-60_0"]]}

% curl http://localhost:8833/ab/test/since/201610024
["20161025"]
% curl http://localhost:8833/ab/test/since/20161026
[]                                 



\end{shell}









\section{Jobtuple and Joblist}

A simple automata starts with defining the function main that takes an
urd object as input

this automata will execute the two methods method1 and method2
consecutively.  Urd will store links to the completed jobs in a
joblist object, accessible by




The jobtuple is a datatype used for storing pairs of names and jobids.
A user typically never creates these, but rather use

\begin{python}

\end{python}


.pretty
.jobid
.method

