\section{Background}

Urd is the primary job dispatcher for the framework, and it is much
more than that.  Urd is a transaction-log-based service keeping track
of all jobs for all users of a framework setup.

The idea is that each user of the framework has one or more locations
in the database where information about executed jobs are stored.
These locations are called urd-lists.  The lists are readable to
anyone, but due to authorisation only writeable by the owning user.

With the exception of experimental work, all work initiated by urd is
run in closed sessons, with a well defined start and ending point.
The input dependencies to these sessions are recorded, together with
the resulting output.



\section{Urd sessions}

A minimal urd session looks like this

\begin{python}
def main(urd):
  urd.begin('test')
  ...
  urd.finish('test', '20161025')
\end{python}
This records any jobs carried out between the begin-finish lines into
the list test with a timestamp of '20161025'.

The session takes a number of options

\begin{python}
  urd.begin(path, timestamp=None, caption=None, update=False)
  urd.finish(path, timestamp=None, caption=None)
\end{python}
and these rules apply
\begin{itemize}
  \item the same path must be specified in both begin and finish.
  \item timestamp is mandatory, but could be set in either begin or
    finish.  Finish overrides begin.
  \item caption is mandatory, but could be set in either begin or
    finish.  Finish overrides begin.
  \item update ???
\end{itemize}

When a session is initiated, a new session cannot start until the
current has finished.  A session may be aborted, however

\begin{python}
  urd.begin('test')
  urd.abort()
\end{python}



\section{Building jobs}

Jobs may be dispatched in a running session.  The syntax is as follows

\begin{python}
  jobid = urd.build('method1', options={}, datasets={}, jobids={},)
\end{python}
where options, datasets, and jobids are optional, depending on the
method to be dispatched.  A jobid is returned upon successful
completion.

In addition, a name and a caption may optionally be specified

\begin{python}
  jobid = urd.build('method1', name='myjob', caption='looking for something')
\end{python}

The name will replace the method name in the joblist, so instead of
having

\begin{python}
  ('method1', 'test-56_0')
\end{python}
it will be

\begin{python}
  ('myjob', 'test-56_0')
\end{python}



It is also possible to build chained jobs implicitly using

\begin{python}
  jobid = urd.build_chained('method1', name='myjob')
\end{python}
which takes exactly the same options as the standard build() method,
with the exception that name is mandatory, since it is used to find
the previous job of matching type.



\section{Sessions with dependency}



\section{Urd HTTP\_API}













\section{An example Urd session}

Consider the following example that dispatches method1, method2, and
method3 consecutively.

\begin{python}
def main(urd):
  urd.begin{'test')
  jid1 = urd.build('method1')
  jid2 = urd.build('method2', jobids=dict(firstjob=jid1)
  jid3 = urd.build('method3', jobids=dict(firstjob=jid1, secondjob=jid2)
  urd.finish('test', '20161025')
\end{python}

now, urd keeps a record of everything that has been build and its
dependencies.  A complete history of executed jobs is stored in the
joblist member, and can be printed pretty like this

\begin{python}
  print urd.joblist.pretty
# JobList(
#    [  0] method1 : test-56_0
#    [  1] method2 : test-57_0
#    [  2] method3 : test-58_0
# )
\end{python}

\begin{python}
  print urd.peek_latest('test')
# {'caption': '',
#  'automata': 'test',
#  'user': 'ab',
#  'deps': {},
#  'timestamp': '20161025',
#  'joblist': JobList([
#     ('method1', 'test-56_0'),
#     ('method2', 'test-59_0'),
#     ('method3', 'test-60_0')
#  ])
# }
\end{python}
\begin{python}
  # and another peek
  print urd.peek_first('test')

  # and another
  print urd.peek('test', '20161026')

  # and another
  print urd.since('test', '20161026')
\end{python}



this can also be achieved by

\begin{shell}
% curl http://localhost:8833/list
["ab/test"]

% curl http://localhost:8833/ab/test/latest
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56_0"],
  ["method2", "test-59_0"], ["method3", "test-60_0"]]}

% curl http://localhost:8833/ab/test/first
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56_0"],
  ["method2", "test-59_0"], ["method3", "test-60_0"]]}

% curl http://localhost:8833/ab/test/20161025              (git)-[99b6358...] 
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56_0"],
  ["method2", "test-59_0"], ["method3", "test-60_0"]]}

% curl http://localhost:8833/ab/test/since/201610024
["20161025"]

% curl http://localhost:8833/ab/test/since/20161026
[]                                 
\end{shell}


% x peek
% x peek\_latest
% x peek\_first
% x since
% X begin
% X abort
% X finish
% x build
% truncate
% get
% latest
% first
% build\_chained


% x @route('/<user>/<automata>/since/<timestamp>')
% x @route('/<user>/<automata>/latest')
% x @route('/<user>/<automata>/first')
% x @route('/<user>/<automata>/<timestamp>')
% x @route('/list')
% @route('/add', method='POST')
% @route('/truncate/<user>/<automata>/<timestamp>', method='POST')








\section{Jobtuple and Joblist}

A simple automata starts with defining the function main that takes an
urd object as input

this automata will execute the two methods method1 and method2
consecutively.  Urd will store links to the completed jobs in a
joblist object, accessible by




The jobtuple is a datatype used for storing pairs of names and jobids.
A user typically never creates these, but rather use
\begin{python}

\end{python}


.pretty
.jobid
.method


\section{api}
Example

\begin{python}
def main(urd):
  latest = urd.latest('ab/neu4')
  print latest
#{
#  'user': 'ab',
#  'automata': 'neu4',
#  'caption': '',
#  'timestamp': '53910101',
#  'joblist': JobList(
#    [
#      ('import_amit', 'neu4-1820_0')
#    ]
#  )
#  'deps': {
#    'ab/neu2': {
#      'caption': 'raw_repository_5391.gz',
#      'timestamp': '53910101'
#      'joblist': JobList(
#        [
#          ('import', 'neu-14679_0'),
#          ('typed', 'neu-14680_0'),
#          ('addcolumns', 'neu2-4893_0')
#        ]
#      ),
#    }
#  },
#}
\end{python}
so the jobid is found by

\begin{python}
  jid = latest.joblist.jobid

  urd.build('my_method',
    datasets = dict(source=jid),
    options = dict(length=3),
  )
\end{python}
and if the result is to be stored in urd:

\begin{python}
  urd.finish()
\end{python}

