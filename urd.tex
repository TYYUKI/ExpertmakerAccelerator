\section{Background}

Urd is a transaction-log-based service keeping track of all jobs for
all users of a framework setup.

The idea is that each user of the framework has one or more locations
in the database where information about executed jobs are stored.
These locations are called urd-lists.  The lists are readable to
anyone, but due to authorisation only writeable by the owning user.




\section{Jobtuple and Joblist}

A simple automata starts with defining the function main that takes an
urd object as input

\begin{python}
def main(urd):
  urd.build('method1', options={})
  urd.build('method2', options={})
\end{python}
this automata will execute the two methods method1 and method2
consecutively.  Urd will store links to the completed jobs in a
joblist object, accessible by




The jobtuple is a datatype used for storing pairs of names and jobids.
A user typically never creates these, but rather use
\begin{python}

\end{python}


.pretty
.jobid
.method


\section{api}
Example

\begin{python}
def main(urd):
  latest = urd.latest('ab/neu4')
  print latest
#{
#  u'user': u'ab',
#  u'automata': u'neu4',
#  u'caption': u'',
#  u'timestamp': u'53910101',
#  u'joblist': JobList(
#    [
#      ('import_amit', 'neu4-1820_0')
#    ]
#  )
#  u'deps': {
#    u'ab/neu2': {
#      u'caption': u'raw_repository_5391.gz',
#      u'timestamp': u'53910101'
#      u'joblist': JobList(
#        [
#          ('import', 'neu-14679_0'),
#          ('typed', 'neu-14680_0'),
#          ('addcolumns', 'neu2-4893_0')
#        ]
#      ),
#    }
#  },
#}
\end{python}
so the jobid is found by

\begin{python}
  jid = latest.joblist.jobid

  urd.build('my_method',
    datasets = dict(source=jid),
    options = dict(length=3),
  )
\end{python}
and if the result is to be stored in urd:

\begin{python}
  urd.finish()
\end{python}


get
latest
first
peek
peek\_latest
peel\_first
since
begin
abort
finish
truncate
build
build\_chained


